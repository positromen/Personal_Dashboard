'use server';

import { prisma } from '@/lib/db';

// =============================================
// TYPES (Derived State - Never Stored)
// =============================================

export type EventType = 'PROJECT' | 'HACKATHON' | 'ACADEMIC' | 'PERSONAL';
export type EventPriority = 'NORMAL' | 'HIGH' | 'CRITICAL';
export type EventState = 'UPCOMING' | 'TODAY' | 'COMPLETED' | 'MISSED';
export type DeadlineConfidence = 'ON_TRACK' | 'TIGHT' | 'AT_RISK';

export interface TaskStats {
    pending: number;
    inProgress: number;
    overdue: number;
    total: number;
}

export interface CalendarEventWithContext {
    id: string;
    title: string;
    date: Date;
    type: EventType;
    priority: EventPriority;
    state: EventState;
    autoGenerated: boolean;
    eventKind: string | null;

    // Context for navigation
    projectId: string | null;
    hackathonId: string | null;

    // Intelligence (for linked items)
    taskStats?: TaskStats;
    confidence?: DeadlineConfidence;

    // Metadata
    description: string | null;
    externalLink: string | null;
}

// =============================================
// STATE DERIVATION (Server-Computed)
// =============================================

function isSameDay(d1: Date, d2: Date): boolean {
    return d1.getFullYear() === d2.getFullYear() &&
        d1.getMonth() === d2.getMonth() &&
        d1.getDate() === d2.getDate();
}

function getDaysUntil(date: Date): number {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const target = new Date(date);
    target.setHours(0, 0, 0, 0);
    return Math.ceil((target.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
}

interface SourceContext {
    type: 'project' | 'hackathon' | null;
    stage?: string;
    status?: string;
}

function deriveEventState(eventDate: Date, source: SourceContext): EventState {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const target = new Date(eventDate);
    target.setHours(0, 0, 0, 0);

    // Check source completion
    if (source.type === 'project' && source.stage === 'completed') return 'COMPLETED';
    if (source.type === 'hackathon' && source.status === 'submitted') return 'COMPLETED';

    // Check date
    if (target < today) return 'MISSED';
    if (isSameDay(target, today)) return 'TODAY';
    return 'UPCOMING';
}

function computeConfidence(eventDate: Date, tasks: { state: string; dueDate: Date | null }[]): DeadlineConfidence {
    const daysRemaining = getDaysUntil(eventDate);
    const totalTasks = tasks.length;

    if (totalTasks === 0) return 'ON_TRACK';

    const pendingTasks = tasks.filter(t => t.state === 'pending' || t.state === 'blocked').length;
    const overdueTasks = tasks.filter(t =>
        t.dueDate && new Date(t.dueDate) < new Date() && t.state !== 'done'
    ).length;

    const completionRate = (totalTasks - pendingTasks) / totalTasks;
    const timeRatio = Math.min(daysRemaining / 14, 1); // Baseline: 2 weeks

    // Critical if any overdue tasks
    if (overdueTasks > 0) return 'AT_RISK';

    // Compare completion rate vs time remaining
    if (completionRate >= timeRatio + 0.2) return 'ON_TRACK';
    if (completionRate >= timeRatio - 0.2) return 'TIGHT';
    return 'AT_RISK';
}

function derivePriority(daysUntil: number): EventPriority {
    if (daysUntil < 3) return 'CRITICAL';
    if (daysUntil < 7) return 'HIGH';
    return 'NORMAL';
}

// =============================================
// QUERIES
// =============================================

/**
 * Get all calendar events for a given month
 */
export async function getCalendarEventsForMonth(year: number, month: number): Promise<CalendarEventWithContext[]> {
    const startOfMonth = new Date(year, month, 1);
    const endOfMonth = new Date(year, month + 1, 0, 23, 59, 59);

    const events = await prisma.calendarEvent.findMany({
        where: {
            date: {
                gte: startOfMonth,
                lte: endOfMonth
            }
        },
        include: {
            project: {
                include: {
                    tasks: {
                        select: { state: true, dueDate: true }
                    }
                }
            },
            hackathon: {
                include: {
                    tasks: {
                        select: { state: true, dueDate: true }
                    }
                }
            }
        },
        orderBy: { date: 'asc' }
    });

    return events.map(event => {
        const source: SourceContext = event.projectId
            ? { type: 'project', stage: event.project?.stage }
            : event.hackathonId
                ? { type: 'hackathon', status: event.hackathon?.status }
                : { type: null };

        const tasks = event.project?.tasks || event.hackathon?.tasks || [];
        const daysUntil = getDaysUntil(event.date);

        // Compute task stats
        const taskStats: TaskStats = {
            pending: tasks.filter(t => t.state === 'pending').length,
            inProgress: tasks.filter(t => t.state === 'in_progress').length,
            overdue: tasks.filter(t =>
                t.dueDate && new Date(t.dueDate) < new Date() && t.state !== 'done'
            ).length,
            total: tasks.length
        };

        return {
            id: event.id,
            title: event.title,
            date: event.date,
            type: event.type as EventType,
            priority: event.autoGenerated ? derivePriority(daysUntil) : event.priority as EventPriority,
            state: deriveEventState(event.date, source),
            autoGenerated: event.autoGenerated,
            eventKind: event.eventKind,
            projectId: event.projectId,
            hackathonId: event.hackathonId,
            taskStats: tasks.length > 0 ? taskStats : undefined,
            confidence: event.autoGenerated && tasks.length > 0
                ? computeConfidence(event.date, tasks)
                : undefined,
            description: event.description,
            externalLink: event.externalLink
        };
    });
}

/**
 * Get upcoming deadlines for sidebar (sorted by urgency)
 */
export async function getUpcomingDeadlines(limit: number = 10): Promise<CalendarEventWithContext[]> {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const events = await prisma.calendarEvent.findMany({
        where: {
            date: { gte: today }
        },
        include: {
            project: {
                include: {
                    tasks: {
                        select: { state: true, dueDate: true }
                    }
                }
            },
            hackathon: {
                include: {
                    tasks: {
                        select: { state: true, dueDate: true }
                    }
                }
            }
        },
        orderBy: { date: 'asc' },
        take: limit
    });

    return events.map(event => {
        const source: SourceContext = event.projectId
            ? { type: 'project', stage: event.project?.stage }
            : event.hackathonId
                ? { type: 'hackathon', status: event.hackathon?.status }
                : { type: null };

        const tasks = event.project?.tasks || event.hackathon?.tasks || [];
        const daysUntil = getDaysUntil(event.date);

        const taskStats: TaskStats = {
            pending: tasks.filter(t => t.state === 'pending').length,
            inProgress: tasks.filter(t => t.state === 'in_progress').length,
            overdue: tasks.filter(t =>
                t.dueDate && new Date(t.dueDate) < new Date() && t.state !== 'done'
            ).length,
            total: tasks.length
        };

        return {
            id: event.id,
            title: event.title,
            date: event.date,
            type: event.type as EventType,
            priority: event.autoGenerated ? derivePriority(daysUntil) : event.priority as EventPriority,
            state: deriveEventState(event.date, source),
            autoGenerated: event.autoGenerated,
            eventKind: event.eventKind,
            projectId: event.projectId,
            hackathonId: event.hackathonId,
            taskStats: tasks.length > 0 ? taskStats : undefined,
            confidence: event.autoGenerated && tasks.length > 0
                ? computeConfidence(event.date, tasks)
                : undefined,
            description: event.description,
            externalLink: event.externalLink
        };
    });
}

/**
 * Get single event by ID (for detail popup)
 */
export async function getCalendarEventById(id: string): Promise<CalendarEventWithContext | null> {
    const event = await prisma.calendarEvent.findUnique({
        where: { id },
        include: {
            project: {
                include: {
                    tasks: {
                        select: { state: true, dueDate: true }
                    }
                }
            },
            hackathon: {
                include: {
                    tasks: {
                        select: { state: true, dueDate: true }
                    }
                }
            }
        }
    });

    if (!event) return null;

    const source: SourceContext = event.projectId
        ? { type: 'project', stage: event.project?.stage }
        : event.hackathonId
            ? { type: 'hackathon', status: event.hackathon?.status }
            : { type: null };

    const tasks = event.project?.tasks || event.hackathon?.tasks || [];
    const daysUntil = getDaysUntil(event.date);

    const taskStats: TaskStats = {
        pending: tasks.filter(t => t.state === 'pending').length,
        inProgress: tasks.filter(t => t.state === 'in_progress').length,
        overdue: tasks.filter(t =>
            t.dueDate && new Date(t.dueDate) < new Date() && t.state !== 'done'
        ).length,
        total: tasks.length
    };

    return {
        id: event.id,
        title: event.title,
        date: event.date,
        type: event.type as EventType,
        priority: event.autoGenerated ? derivePriority(daysUntil) : event.priority as EventPriority,
        state: deriveEventState(event.date, source),
        autoGenerated: event.autoGenerated,
        eventKind: event.eventKind,
        projectId: event.projectId,
        hackathonId: event.hackathonId,
        taskStats: tasks.length > 0 ? taskStats : undefined,
        confidence: event.autoGenerated && tasks.length > 0
            ? computeConfidence(event.date, tasks)
            : undefined,
        description: event.description,
        externalLink: event.externalLink
    };
}
