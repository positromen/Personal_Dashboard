'use server';

import { prisma } from '@/lib/db';
import { revalidatePath } from 'next/cache';

// =============================================
// TYPES
// =============================================

export type EventType = 'PROJECT' | 'HACKATHON' | 'ACADEMIC' | 'PERSONAL';
export type EventPriority = 'NORMAL' | 'HIGH' | 'CRITICAL';

interface ManualEventInput {
    title: string;
    date: string; // ISO date string
    type: 'ACADEMIC' | 'PERSONAL';
    priority?: EventPriority;
    description?: string;
    externalLink?: string;
}

// =============================================
// AUTO-GENERATION: HACKATHON EVENTS
// Called when hackathon is created or dates updated
// =============================================

export async function syncHackathonCalendarEvents(hackathonId: string) {
    const hackathon = await prisma.hackathon.findUnique({
        where: { id: hackathonId },
        include: { calendarEvents: true }
    });

    if (!hackathon) {
        throw new Error('Hackathon not found');
    }

    // Delete existing auto-generated events for this hackathon
    await prisma.calendarEvent.deleteMany({
        where: {
            hackathonId,
            autoGenerated: true
        }
    });

    const eventsToCreate: {
        title: string;
        date: Date;
        eventKind: string;
    }[] = [];

    // Registration Deadline
    if (hackathon.registrationDeadline) {
        eventsToCreate.push({
            title: `ðŸ“ ${hackathon.name} - Registration Deadline`,
            date: hackathon.registrationDeadline,
            eventKind: 'registration'
        });
    }

    // Submission Deadline
    if (hackathon.submissionDeadline) {
        eventsToCreate.push({
            title: `ðŸš€ ${hackathon.name} - Submission Deadline`,
            date: hackathon.submissionDeadline,
            eventKind: 'submission'
        });
    }

    // Event Start Date
    if (hackathon.eventStartDate) {
        eventsToCreate.push({
            title: `âš¡ ${hackathon.name} - Event Start`,
            date: hackathon.eventStartDate,
            eventKind: 'event_start'
        });
    }

    // Create all events
    if (eventsToCreate.length > 0) {
        await prisma.calendarEvent.createMany({
            data: eventsToCreate.map(e => ({
                title: e.title,
                date: e.date,
                type: 'HACKATHON',
                priority: 'HIGH',
                autoGenerated: true,
                sourceType: 'hackathon',
                eventKind: e.eventKind,
                hackathonId,
                description: `Auto-generated from hackathon: ${hackathon.name}`
            }))
        });
    }

    revalidatePath('/calendar');
    return { created: eventsToCreate.length };
}

// =============================================
// AUTO-GENERATION: PROJECT DEADLINE
// Called when project deadline is set or updated
// =============================================

export async function syncProjectCalendarEvents(projectId: string) {
    const project = await prisma.project.findUnique({
        where: { id: projectId },
        include: { calendarEvents: true }
    });

    if (!project) {
        throw new Error('Project not found');
    }

    // Delete existing auto-generated events for this project
    await prisma.calendarEvent.deleteMany({
        where: {
            projectId,
            autoGenerated: true
        }
    });

    // Create deadline event if project has deadline
    if (project.deadline) {
        await prisma.calendarEvent.create({
            data: {
                title: `ðŸ“… ${project.name} - Deadline`,
                date: project.deadline,
                type: 'PROJECT',
                priority: 'HIGH',
                autoGenerated: true,
                sourceType: 'project',
                eventKind: 'deadline',
                projectId,
                description: `Auto-generated from project: ${project.name}`
            }
        });
    }

    revalidatePath('/calendar');
    return { synced: true };
}

// =============================================
// MANUAL EVENT CREATION (Academic/Personal only)
// =============================================

export async function createManualEvent(input: ManualEventInput) {
    // Validate type - only ACADEMIC and PERSONAL allowed for manual creation
    if (input.type !== 'ACADEMIC' && input.type !== 'PERSONAL') {
        throw new Error('Manual events can only be ACADEMIC or PERSONAL type');
    }

    const event = await prisma.calendarEvent.create({
        data: {
            title: input.title,
            date: new Date(input.date),
            type: input.type,
            priority: input.priority || 'NORMAL',
            autoGenerated: false,
            sourceType: null,
            eventKind: null,
            projectId: null,
            hackathonId: null,
            description: input.description || null,
            externalLink: input.externalLink || null
        }
    });

    revalidatePath('/calendar');
    return event;
}

// =============================================
// DELETE MANUAL EVENT
// Auto-generated events cannot be deleted manually
// =============================================

export async function deleteManualEvent(id: string) {
    const event = await prisma.calendarEvent.findUnique({
        where: { id }
    });

    if (!event) {
        throw new Error('Event not found');
    }

    if (event.autoGenerated) {
        throw new Error('Cannot delete auto-generated events. Delete the source hackathon or project instead.');
    }

    await prisma.calendarEvent.delete({
        where: { id }
    });

    revalidatePath('/calendar');
    return { deleted: true };
}

// =============================================
// UPDATE MANUAL EVENT
// Auto-generated events are read-only
// =============================================

export async function updateManualEvent(
    id: string,
    updates: Partial<Omit<ManualEventInput, 'type'>>
) {
    const event = await prisma.calendarEvent.findUnique({
        where: { id }
    });

    if (!event) {
        throw new Error('Event not found');
    }

    if (event.autoGenerated) {
        throw new Error('Cannot edit auto-generated events. Edit the source hackathon or project instead.');
    }

    const updatedEvent = await prisma.calendarEvent.update({
        where: { id },
        data: {
            title: updates.title,
            date: updates.date ? new Date(updates.date) : undefined,
            priority: updates.priority,
            description: updates.description,
            externalLink: updates.externalLink
        }
    });

    revalidatePath('/calendar');
    return updatedEvent;
}

// =============================================
// BULK SYNC (Initial migration)
// Sync all existing hackathons and projects
// =============================================

export async function syncAllCalendarEvents() {
    // Get all hackathons
    const hackathons = await prisma.hackathon.findMany({
        select: { id: true }
    });

    // Get all projects with deadlines
    const projects = await prisma.project.findMany({
        where: { deadline: { not: null } },
        select: { id: true }
    });

    // Sync each
    let hackathonCount = 0;
    let projectCount = 0;

    for (const h of hackathons) {
        await syncHackathonCalendarEvents(h.id);
        hackathonCount++;
    }

    for (const p of projects) {
        await syncProjectCalendarEvents(p.id);
        projectCount++;
    }

    revalidatePath('/calendar');
    return {
        hackathonsSynced: hackathonCount,
        projectsSynced: projectCount
    };
}
